//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

@_exported import SotoCore

/// Service object for interacting with AWS AppSync service.
///
/// AWS AppSync provides API actions for creating and interacting with data sources using GraphQL from your application.
public struct AppSync: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the AppSync client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - timeout: Timeout value for HTTP requests
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            service: "appsync",
            serviceProtocol: .restjson,
            apiVersion: "2017-07-25",
            endpoint: endpoint,
            errorType: AppSyncErrorType.self,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }

    // MARK: API Calls

    /// Creates a cache for the GraphQL API.
    public func createApiCache(_ input: CreateApiCacheRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateApiCacheResponse> {
        return self.client.execute(operation: "CreateApiCache", path: "/v1/apis/{apiId}/ApiCaches", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Creates a unique key that you can distribute to clients who are executing your API.
    public func createApiKey(_ input: CreateApiKeyRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateApiKeyResponse> {
        return self.client.execute(operation: "CreateApiKey", path: "/v1/apis/{apiId}/apikeys", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Creates a DataSource object.
    public func createDataSource(_ input: CreateDataSourceRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateDataSourceResponse> {
        return self.client.execute(operation: "CreateDataSource", path: "/v1/apis/{apiId}/datasources", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Creates a Function object. A function is a reusable entity. Multiple functions can be used to compose the resolver logic.
    public func createFunction(_ input: CreateFunctionRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateFunctionResponse> {
        return self.client.execute(operation: "CreateFunction", path: "/v1/apis/{apiId}/functions", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Creates a GraphqlApi object.
    public func createGraphqlApi(_ input: CreateGraphqlApiRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateGraphqlApiResponse> {
        return self.client.execute(operation: "CreateGraphqlApi", path: "/v1/apis", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Creates a Resolver object. A resolver converts incoming requests into a format that a data source can understand and converts the data source's responses into GraphQL.
    public func createResolver(_ input: CreateResolverRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateResolverResponse> {
        return self.client.execute(operation: "CreateResolver", path: "/v1/apis/{apiId}/types/{typeName}/resolvers", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Creates a Type object.
    public func createType(_ input: CreateTypeRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateTypeResponse> {
        return self.client.execute(operation: "CreateType", path: "/v1/apis/{apiId}/types", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes an ApiCache object.
    public func deleteApiCache(_ input: DeleteApiCacheRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteApiCacheResponse> {
        return self.client.execute(operation: "DeleteApiCache", path: "/v1/apis/{apiId}/ApiCaches", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes an API key.
    public func deleteApiKey(_ input: DeleteApiKeyRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteApiKeyResponse> {
        return self.client.execute(operation: "DeleteApiKey", path: "/v1/apis/{apiId}/apikeys/{id}", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes a DataSource object.
    public func deleteDataSource(_ input: DeleteDataSourceRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteDataSourceResponse> {
        return self.client.execute(operation: "DeleteDataSource", path: "/v1/apis/{apiId}/datasources/{name}", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes a Function.
    public func deleteFunction(_ input: DeleteFunctionRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteFunctionResponse> {
        return self.client.execute(operation: "DeleteFunction", path: "/v1/apis/{apiId}/functions/{functionId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes a GraphqlApi object.
    public func deleteGraphqlApi(_ input: DeleteGraphqlApiRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteGraphqlApiResponse> {
        return self.client.execute(operation: "DeleteGraphqlApi", path: "/v1/apis/{apiId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes a Resolver object.
    public func deleteResolver(_ input: DeleteResolverRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteResolverResponse> {
        return self.client.execute(operation: "DeleteResolver", path: "/v1/apis/{apiId}/types/{typeName}/resolvers/{fieldName}", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes a Type object.
    public func deleteType(_ input: DeleteTypeRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteTypeResponse> {
        return self.client.execute(operation: "DeleteType", path: "/v1/apis/{apiId}/types/{typeName}", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Flushes an ApiCache object.
    public func flushApiCache(_ input: FlushApiCacheRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<FlushApiCacheResponse> {
        return self.client.execute(operation: "FlushApiCache", path: "/v1/apis/{apiId}/FlushCache", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Retrieves an ApiCache object.
    public func getApiCache(_ input: GetApiCacheRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetApiCacheResponse> {
        return self.client.execute(operation: "GetApiCache", path: "/v1/apis/{apiId}/ApiCaches", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Retrieves a DataSource object.
    public func getDataSource(_ input: GetDataSourceRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetDataSourceResponse> {
        return self.client.execute(operation: "GetDataSource", path: "/v1/apis/{apiId}/datasources/{name}", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Get a Function.
    public func getFunction(_ input: GetFunctionRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetFunctionResponse> {
        return self.client.execute(operation: "GetFunction", path: "/v1/apis/{apiId}/functions/{functionId}", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Retrieves a GraphqlApi object.
    public func getGraphqlApi(_ input: GetGraphqlApiRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetGraphqlApiResponse> {
        return self.client.execute(operation: "GetGraphqlApi", path: "/v1/apis/{apiId}", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Retrieves the introspection schema for a GraphQL API.
    public func getIntrospectionSchema(_ input: GetIntrospectionSchemaRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetIntrospectionSchemaResponse> {
        return self.client.execute(operation: "GetIntrospectionSchema", path: "/v1/apis/{apiId}/schema", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Retrieves a Resolver object.
    public func getResolver(_ input: GetResolverRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetResolverResponse> {
        return self.client.execute(operation: "GetResolver", path: "/v1/apis/{apiId}/types/{typeName}/resolvers/{fieldName}", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Retrieves the current status of a schema creation operation.
    public func getSchemaCreationStatus(_ input: GetSchemaCreationStatusRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetSchemaCreationStatusResponse> {
        return self.client.execute(operation: "GetSchemaCreationStatus", path: "/v1/apis/{apiId}/schemacreation", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Retrieves a Type object.
    public func getType(_ input: GetTypeRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetTypeResponse> {
        return self.client.execute(operation: "GetType", path: "/v1/apis/{apiId}/types/{typeName}", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Lists the API keys for a given API.  API keys are deleted automatically 60 days after they expire. However, they may still be included in the response until they have actually been deleted. You can safely call DeleteApiKey to manually delete a key before it's automatically deleted.
    public func listApiKeys(_ input: ListApiKeysRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListApiKeysResponse> {
        return self.client.execute(operation: "ListApiKeys", path: "/v1/apis/{apiId}/apikeys", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Lists the data sources for a given API.
    public func listDataSources(_ input: ListDataSourcesRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListDataSourcesResponse> {
        return self.client.execute(operation: "ListDataSources", path: "/v1/apis/{apiId}/datasources", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// List multiple functions.
    public func listFunctions(_ input: ListFunctionsRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListFunctionsResponse> {
        return self.client.execute(operation: "ListFunctions", path: "/v1/apis/{apiId}/functions", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Lists your GraphQL APIs.
    public func listGraphqlApis(_ input: ListGraphqlApisRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListGraphqlApisResponse> {
        return self.client.execute(operation: "ListGraphqlApis", path: "/v1/apis", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Lists the resolvers for a given API and type.
    public func listResolvers(_ input: ListResolversRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListResolversResponse> {
        return self.client.execute(operation: "ListResolvers", path: "/v1/apis/{apiId}/types/{typeName}/resolvers", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// List the resolvers that are associated with a specific function.
    public func listResolversByFunction(_ input: ListResolversByFunctionRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListResolversByFunctionResponse> {
        return self.client.execute(operation: "ListResolversByFunction", path: "/v1/apis/{apiId}/functions/{functionId}/resolvers", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Lists the tags for a resource.
    public func listTagsForResource(_ input: ListTagsForResourceRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListTagsForResourceResponse> {
        return self.client.execute(operation: "ListTagsForResource", path: "/v1/tags/{resourceArn}", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Lists the types for a given API.
    public func listTypes(_ input: ListTypesRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListTypesResponse> {
        return self.client.execute(operation: "ListTypes", path: "/v1/apis/{apiId}/types", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Adds a new schema to your GraphQL API. This operation is asynchronous. Use to determine when it has completed.
    public func startSchemaCreation(_ input: StartSchemaCreationRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<StartSchemaCreationResponse> {
        return self.client.execute(operation: "StartSchemaCreation", path: "/v1/apis/{apiId}/schemacreation", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Tags a resource with user-supplied tags.
    public func tagResource(_ input: TagResourceRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<TagResourceResponse> {
        return self.client.execute(operation: "TagResource", path: "/v1/tags/{resourceArn}", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Untags a resource.
    public func untagResource(_ input: UntagResourceRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UntagResourceResponse> {
        return self.client.execute(operation: "UntagResource", path: "/v1/tags/{resourceArn}", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Updates the cache for the GraphQL API.
    public func updateApiCache(_ input: UpdateApiCacheRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateApiCacheResponse> {
        return self.client.execute(operation: "UpdateApiCache", path: "/v1/apis/{apiId}/ApiCaches/update", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Updates an API key. The key can be updated while it is not deleted.
    public func updateApiKey(_ input: UpdateApiKeyRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateApiKeyResponse> {
        return self.client.execute(operation: "UpdateApiKey", path: "/v1/apis/{apiId}/apikeys/{id}", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Updates a DataSource object.
    public func updateDataSource(_ input: UpdateDataSourceRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateDataSourceResponse> {
        return self.client.execute(operation: "UpdateDataSource", path: "/v1/apis/{apiId}/datasources/{name}", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Updates a Function object.
    public func updateFunction(_ input: UpdateFunctionRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateFunctionResponse> {
        return self.client.execute(operation: "UpdateFunction", path: "/v1/apis/{apiId}/functions/{functionId}", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Updates a GraphqlApi object.
    public func updateGraphqlApi(_ input: UpdateGraphqlApiRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateGraphqlApiResponse> {
        return self.client.execute(operation: "UpdateGraphqlApi", path: "/v1/apis/{apiId}", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Updates a Resolver object.
    public func updateResolver(_ input: UpdateResolverRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateResolverResponse> {
        return self.client.execute(operation: "UpdateResolver", path: "/v1/apis/{apiId}/types/{typeName}/resolvers/{fieldName}", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Updates a Type object.
    public func updateType(_ input: UpdateTypeRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateTypeResponse> {
        return self.client.execute(operation: "UpdateType", path: "/v1/apis/{apiId}/types/{typeName}", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }
}

extension AppSync {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are no public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: AppSync, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}
