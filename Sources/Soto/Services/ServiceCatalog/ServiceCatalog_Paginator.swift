//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import SotoCore

// MARK: Paginators

extension ServiceCatalog {
    ///  Returns a summary of each of the portfolio shares that were created for the specified portfolio. You can use this API to determine which accounts or organizational nodes this portfolio have been shared, whether the recipient entity has imported the share, and whether TagOptions are included with the share. The PortfolioId and Type parameters are both required.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describePortfolioSharesPaginator<Result>(
        _ input: DescribePortfolioSharesInput,
        _ initialValue: Result,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribePortfolioSharesOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describePortfolioShares,
            inputKey: \DescribePortfolioSharesInput.pageToken,
            outputKey: \DescribePortfolioSharesOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describePortfolioSharesPaginator(
        _ input: DescribePortfolioSharesInput,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribePortfolioSharesOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describePortfolioShares,
            inputKey: \DescribePortfolioSharesInput.pageToken,
            outputKey: \DescribePortfolioSharesOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  This API takes either a ProvisonedProductId or a ProvisionedProductName, along with a list of one or more output keys, and responds with the key/value pairs of those outputs.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func getProvisionedProductOutputsPaginator<Result>(
        _ input: GetProvisionedProductOutputsInput,
        _ initialValue: Result,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, GetProvisionedProductOutputsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: getProvisionedProductOutputs,
            inputKey: \GetProvisionedProductOutputsInput.pageToken,
            outputKey: \GetProvisionedProductOutputsOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func getProvisionedProductOutputsPaginator(
        _ input: GetProvisionedProductOutputsInput,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (GetProvisionedProductOutputsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: getProvisionedProductOutputs,
            inputKey: \GetProvisionedProductOutputsInput.pageToken,
            outputKey: \GetProvisionedProductOutputsOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all portfolios for which sharing was accepted by this account.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAcceptedPortfolioSharesPaginator<Result>(
        _ input: ListAcceptedPortfolioSharesInput,
        _ initialValue: Result,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListAcceptedPortfolioSharesOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAcceptedPortfolioShares,
            inputKey: \ListAcceptedPortfolioSharesInput.pageToken,
            outputKey: \ListAcceptedPortfolioSharesOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAcceptedPortfolioSharesPaginator(
        _ input: ListAcceptedPortfolioSharesInput,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListAcceptedPortfolioSharesOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAcceptedPortfolioShares,
            inputKey: \ListAcceptedPortfolioSharesInput.pageToken,
            outputKey: \ListAcceptedPortfolioSharesOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all the budgets associated to the specified resource.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listBudgetsForResourcePaginator<Result>(
        _ input: ListBudgetsForResourceInput,
        _ initialValue: Result,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListBudgetsForResourceOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listBudgetsForResource,
            inputKey: \ListBudgetsForResourceInput.pageToken,
            outputKey: \ListBudgetsForResourceOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listBudgetsForResourcePaginator(
        _ input: ListBudgetsForResourceInput,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListBudgetsForResourceOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listBudgetsForResource,
            inputKey: \ListBudgetsForResourceInput.pageToken,
            outputKey: \ListBudgetsForResourceOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the constraints for the specified portfolio and product.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listConstraintsForPortfolioPaginator<Result>(
        _ input: ListConstraintsForPortfolioInput,
        _ initialValue: Result,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListConstraintsForPortfolioOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listConstraintsForPortfolio,
            inputKey: \ListConstraintsForPortfolioInput.pageToken,
            outputKey: \ListConstraintsForPortfolioOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listConstraintsForPortfolioPaginator(
        _ input: ListConstraintsForPortfolioInput,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListConstraintsForPortfolioOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listConstraintsForPortfolio,
            inputKey: \ListConstraintsForPortfolioInput.pageToken,
            outputKey: \ListConstraintsForPortfolioOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the paths to the specified product. A path is how the user has access to a specified product, and is necessary when provisioning a product. A path also determines the constraints put on the product.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listLaunchPathsPaginator<Result>(
        _ input: ListLaunchPathsInput,
        _ initialValue: Result,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListLaunchPathsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listLaunchPaths,
            inputKey: \ListLaunchPathsInput.pageToken,
            outputKey: \ListLaunchPathsOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listLaunchPathsPaginator(
        _ input: ListLaunchPathsInput,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListLaunchPathsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listLaunchPaths,
            inputKey: \ListLaunchPathsInput.pageToken,
            outputKey: \ListLaunchPathsOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the organization nodes that have access to the specified portfolio. This API can only be called by the management account in the organization or by a delegated admin. If a delegated admin is de-registered, they can no longer perform this operation.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listOrganizationPortfolioAccessPaginator<Result>(
        _ input: ListOrganizationPortfolioAccessInput,
        _ initialValue: Result,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListOrganizationPortfolioAccessOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listOrganizationPortfolioAccess,
            inputKey: \ListOrganizationPortfolioAccessInput.pageToken,
            outputKey: \ListOrganizationPortfolioAccessOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listOrganizationPortfolioAccessPaginator(
        _ input: ListOrganizationPortfolioAccessInput,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListOrganizationPortfolioAccessOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listOrganizationPortfolioAccess,
            inputKey: \ListOrganizationPortfolioAccessInput.pageToken,
            outputKey: \ListOrganizationPortfolioAccessOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the account IDs that have access to the specified portfolio. A delegated admin can list the accounts that have access to the shared portfolio. Note that if a delegated admin is de-registered, they can no longer perform this operation.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listPortfolioAccessPaginator<Result>(
        _ input: ListPortfolioAccessInput,
        _ initialValue: Result,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListPortfolioAccessOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listPortfolioAccess,
            inputKey: \ListPortfolioAccessInput.pageToken,
            outputKey: \ListPortfolioAccessOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listPortfolioAccessPaginator(
        _ input: ListPortfolioAccessInput,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListPortfolioAccessOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listPortfolioAccess,
            inputKey: \ListPortfolioAccessInput.pageToken,
            outputKey: \ListPortfolioAccessOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all portfolios in the catalog.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listPortfoliosPaginator<Result>(
        _ input: ListPortfoliosInput,
        _ initialValue: Result,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListPortfoliosOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listPortfolios,
            inputKey: \ListPortfoliosInput.pageToken,
            outputKey: \ListPortfoliosOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listPortfoliosPaginator(
        _ input: ListPortfoliosInput,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListPortfoliosOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listPortfolios,
            inputKey: \ListPortfoliosInput.pageToken,
            outputKey: \ListPortfoliosOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all portfolios that the specified product is associated with.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listPortfoliosForProductPaginator<Result>(
        _ input: ListPortfoliosForProductInput,
        _ initialValue: Result,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListPortfoliosForProductOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listPortfoliosForProduct,
            inputKey: \ListPortfoliosForProductInput.pageToken,
            outputKey: \ListPortfoliosForProductOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listPortfoliosForProductPaginator(
        _ input: ListPortfoliosForProductInput,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListPortfoliosForProductOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listPortfoliosForProduct,
            inputKey: \ListPortfoliosForProductInput.pageToken,
            outputKey: \ListPortfoliosForProductOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all principal ARNs associated with the specified portfolio.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listPrincipalsForPortfolioPaginator<Result>(
        _ input: ListPrincipalsForPortfolioInput,
        _ initialValue: Result,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListPrincipalsForPortfolioOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listPrincipalsForPortfolio,
            inputKey: \ListPrincipalsForPortfolioInput.pageToken,
            outputKey: \ListPrincipalsForPortfolioOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listPrincipalsForPortfolioPaginator(
        _ input: ListPrincipalsForPortfolioInput,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListPrincipalsForPortfolioOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listPrincipalsForPortfolio,
            inputKey: \ListPrincipalsForPortfolioInput.pageToken,
            outputKey: \ListPrincipalsForPortfolioOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all provisioning artifacts (also known as versions) for the specified self-service action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listProvisioningArtifactsForServiceActionPaginator<Result>(
        _ input: ListProvisioningArtifactsForServiceActionInput,
        _ initialValue: Result,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListProvisioningArtifactsForServiceActionOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listProvisioningArtifactsForServiceAction,
            inputKey: \ListProvisioningArtifactsForServiceActionInput.pageToken,
            outputKey: \ListProvisioningArtifactsForServiceActionOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listProvisioningArtifactsForServiceActionPaginator(
        _ input: ListProvisioningArtifactsForServiceActionInput,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListProvisioningArtifactsForServiceActionOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listProvisioningArtifactsForServiceAction,
            inputKey: \ListProvisioningArtifactsForServiceActionInput.pageToken,
            outputKey: \ListProvisioningArtifactsForServiceActionOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the resources associated with the specified TagOption.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listResourcesForTagOptionPaginator<Result>(
        _ input: ListResourcesForTagOptionInput,
        _ initialValue: Result,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListResourcesForTagOptionOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listResourcesForTagOption,
            inputKey: \ListResourcesForTagOptionInput.pageToken,
            outputKey: \ListResourcesForTagOptionOutput.pageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listResourcesForTagOptionPaginator(
        _ input: ListResourcesForTagOptionInput,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListResourcesForTagOptionOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listResourcesForTagOption,
            inputKey: \ListResourcesForTagOptionInput.pageToken,
            outputKey: \ListResourcesForTagOptionOutput.pageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all self-service actions.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listServiceActionsPaginator<Result>(
        _ input: ListServiceActionsInput,
        _ initialValue: Result,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListServiceActionsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listServiceActions,
            inputKey: \ListServiceActionsInput.pageToken,
            outputKey: \ListServiceActionsOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listServiceActionsPaginator(
        _ input: ListServiceActionsInput,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListServiceActionsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listServiceActions,
            inputKey: \ListServiceActionsInput.pageToken,
            outputKey: \ListServiceActionsOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a paginated list of self-service actions associated with the specified Product ID and Provisioning Artifact ID.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listServiceActionsForProvisioningArtifactPaginator<Result>(
        _ input: ListServiceActionsForProvisioningArtifactInput,
        _ initialValue: Result,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListServiceActionsForProvisioningArtifactOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listServiceActionsForProvisioningArtifact,
            inputKey: \ListServiceActionsForProvisioningArtifactInput.pageToken,
            outputKey: \ListServiceActionsForProvisioningArtifactOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listServiceActionsForProvisioningArtifactPaginator(
        _ input: ListServiceActionsForProvisioningArtifactInput,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListServiceActionsForProvisioningArtifactOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listServiceActionsForProvisioningArtifact,
            inputKey: \ListServiceActionsForProvisioningArtifactInput.pageToken,
            outputKey: \ListServiceActionsForProvisioningArtifactOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the specified TagOptions or all TagOptions.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listTagOptionsPaginator<Result>(
        _ input: ListTagOptionsInput,
        _ initialValue: Result,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListTagOptionsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listTagOptions,
            inputKey: \ListTagOptionsInput.pageToken,
            outputKey: \ListTagOptionsOutput.pageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listTagOptionsPaginator(
        _ input: ListTagOptionsInput,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListTagOptionsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listTagOptions,
            inputKey: \ListTagOptionsInput.pageToken,
            outputKey: \ListTagOptionsOutput.pageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets information about the products to which the caller has access.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func searchProductsPaginator<Result>(
        _ input: SearchProductsInput,
        _ initialValue: Result,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, SearchProductsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: searchProducts,
            inputKey: \SearchProductsInput.pageToken,
            outputKey: \SearchProductsOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func searchProductsPaginator(
        _ input: SearchProductsInput,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (SearchProductsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: searchProducts,
            inputKey: \SearchProductsInput.pageToken,
            outputKey: \SearchProductsOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets information about the products for the specified portfolio or all products.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func searchProductsAsAdminPaginator<Result>(
        _ input: SearchProductsAsAdminInput,
        _ initialValue: Result,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, SearchProductsAsAdminOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: searchProductsAsAdmin,
            inputKey: \SearchProductsAsAdminInput.pageToken,
            outputKey: \SearchProductsAsAdminOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func searchProductsAsAdminPaginator(
        _ input: SearchProductsAsAdminInput,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (SearchProductsAsAdminOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: searchProductsAsAdmin,
            inputKey: \SearchProductsAsAdminInput.pageToken,
            outputKey: \SearchProductsAsAdminOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets information about the provisioned products that meet the specified criteria.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func searchProvisionedProductsPaginator<Result>(
        _ input: SearchProvisionedProductsInput,
        _ initialValue: Result,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, SearchProvisionedProductsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: searchProvisionedProducts,
            inputKey: \SearchProvisionedProductsInput.pageToken,
            outputKey: \SearchProvisionedProductsOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - context: LoggingContext used for instrumentation
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func searchProvisionedProductsPaginator(
        _ input: SearchProvisionedProductsInput,
        context: LoggingContext,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (SearchProvisionedProductsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: searchProvisionedProducts,
            inputKey: \SearchProvisionedProductsInput.pageToken,
            outputKey: \SearchProvisionedProductsOutput.nextPageToken,
            context: context,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension ServiceCatalog.DescribePortfolioSharesInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.DescribePortfolioSharesInput {
        return .init(
            pageSize: self.pageSize,
            pageToken: token,
            portfolioId: self.portfolioId,
            type: self.type
        )
    }
}

extension ServiceCatalog.GetProvisionedProductOutputsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.GetProvisionedProductOutputsInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            outputKeys: self.outputKeys,
            pageSize: self.pageSize,
            pageToken: token,
            provisionedProductId: self.provisionedProductId,
            provisionedProductName: self.provisionedProductName
        )
    }
}

extension ServiceCatalog.ListAcceptedPortfolioSharesInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListAcceptedPortfolioSharesInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            portfolioShareType: self.portfolioShareType
        )
    }
}

extension ServiceCatalog.ListBudgetsForResourceInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListBudgetsForResourceInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            resourceId: self.resourceId
        )
    }
}

extension ServiceCatalog.ListConstraintsForPortfolioInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListConstraintsForPortfolioInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            portfolioId: self.portfolioId,
            productId: self.productId
        )
    }
}

extension ServiceCatalog.ListLaunchPathsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListLaunchPathsInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            productId: self.productId
        )
    }
}

extension ServiceCatalog.ListOrganizationPortfolioAccessInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListOrganizationPortfolioAccessInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            organizationNodeType: self.organizationNodeType,
            pageSize: self.pageSize,
            pageToken: token,
            portfolioId: self.portfolioId
        )
    }
}

extension ServiceCatalog.ListPortfolioAccessInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListPortfolioAccessInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            organizationParentId: self.organizationParentId,
            pageSize: self.pageSize,
            pageToken: token,
            portfolioId: self.portfolioId
        )
    }
}

extension ServiceCatalog.ListPortfoliosInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListPortfoliosInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token
        )
    }
}

extension ServiceCatalog.ListPortfoliosForProductInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListPortfoliosForProductInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            productId: self.productId
        )
    }
}

extension ServiceCatalog.ListPrincipalsForPortfolioInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListPrincipalsForPortfolioInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            portfolioId: self.portfolioId
        )
    }
}

extension ServiceCatalog.ListProvisioningArtifactsForServiceActionInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListProvisioningArtifactsForServiceActionInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            serviceActionId: self.serviceActionId
        )
    }
}

extension ServiceCatalog.ListResourcesForTagOptionInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListResourcesForTagOptionInput {
        return .init(
            pageSize: self.pageSize,
            pageToken: token,
            resourceType: self.resourceType,
            tagOptionId: self.tagOptionId
        )
    }
}

extension ServiceCatalog.ListServiceActionsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListServiceActionsInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token
        )
    }
}

extension ServiceCatalog.ListServiceActionsForProvisioningArtifactInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListServiceActionsForProvisioningArtifactInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            productId: self.productId,
            provisioningArtifactId: self.provisioningArtifactId
        )
    }
}

extension ServiceCatalog.ListTagOptionsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListTagOptionsInput {
        return .init(
            filters: self.filters,
            pageSize: self.pageSize,
            pageToken: token
        )
    }
}

extension ServiceCatalog.SearchProductsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.SearchProductsInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            filters: self.filters,
            pageSize: self.pageSize,
            pageToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )
    }
}

extension ServiceCatalog.SearchProductsAsAdminInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.SearchProductsAsAdminInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            filters: self.filters,
            pageSize: self.pageSize,
            pageToken: token,
            portfolioId: self.portfolioId,
            productSource: self.productSource,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )
    }
}

extension ServiceCatalog.SearchProvisionedProductsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.SearchProvisionedProductsInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            accessLevelFilter: self.accessLevelFilter,
            filters: self.filters,
            pageSize: self.pageSize,
            pageToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )
    }
}
