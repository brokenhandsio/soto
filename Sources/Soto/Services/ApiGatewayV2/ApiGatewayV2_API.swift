//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

@_exported import SotoCore

/// Service object for interacting with AWS ApiGatewayV2 service.
///
/// Amazon API Gateway V2
public struct ApiGatewayV2: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the ApiGatewayV2 client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - timeout: Timeout value for HTTP requests
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            service: "apigateway",
            serviceProtocol: .restjson,
            apiVersion: "2018-11-29",
            endpoint: endpoint,
            errorType: ApiGatewayV2ErrorType.self,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }

    // MARK: API Calls

    /// Creates an Api resource.
    public func createApi(_ input: CreateApiRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateApiResponse> {
        return self.client.execute(operation: "CreateApi", path: "/v2/apis", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Creates an API mapping.
    public func createApiMapping(_ input: CreateApiMappingRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateApiMappingResponse> {
        return self.client.execute(operation: "CreateApiMapping", path: "/v2/domainnames/{domainName}/apimappings", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Creates an Authorizer for an API.
    public func createAuthorizer(_ input: CreateAuthorizerRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateAuthorizerResponse> {
        return self.client.execute(operation: "CreateAuthorizer", path: "/v2/apis/{apiId}/authorizers", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Creates a Deployment for an API.
    public func createDeployment(_ input: CreateDeploymentRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateDeploymentResponse> {
        return self.client.execute(operation: "CreateDeployment", path: "/v2/apis/{apiId}/deployments", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Creates a domain name.
    public func createDomainName(_ input: CreateDomainNameRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateDomainNameResponse> {
        return self.client.execute(operation: "CreateDomainName", path: "/v2/domainnames", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Creates an Integration.
    public func createIntegration(_ input: CreateIntegrationRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateIntegrationResult> {
        return self.client.execute(operation: "CreateIntegration", path: "/v2/apis/{apiId}/integrations", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Creates an IntegrationResponses.
    public func createIntegrationResponse(_ input: CreateIntegrationResponseRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateIntegrationResponseResponse> {
        return self.client.execute(operation: "CreateIntegrationResponse", path: "/v2/apis/{apiId}/integrations/{integrationId}/integrationresponses", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Creates a Model for an API.
    public func createModel(_ input: CreateModelRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateModelResponse> {
        return self.client.execute(operation: "CreateModel", path: "/v2/apis/{apiId}/models", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Creates a Route for an API.
    public func createRoute(_ input: CreateRouteRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateRouteResult> {
        return self.client.execute(operation: "CreateRoute", path: "/v2/apis/{apiId}/routes", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Creates a RouteResponse for a Route.
    public func createRouteResponse(_ input: CreateRouteResponseRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateRouteResponseResponse> {
        return self.client.execute(operation: "CreateRouteResponse", path: "/v2/apis/{apiId}/routes/{routeId}/routeresponses", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Creates a Stage for an API.
    public func createStage(_ input: CreateStageRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateStageResponse> {
        return self.client.execute(operation: "CreateStage", path: "/v2/apis/{apiId}/stages", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Creates a VPC link.
    public func createVpcLink(_ input: CreateVpcLinkRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateVpcLinkResponse> {
        return self.client.execute(operation: "CreateVpcLink", path: "/v2/vpclinks", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes the AccessLogSettings for a Stage. To disable access logging for a Stage, delete its AccessLogSettings.
    @discardableResult public func deleteAccessLogSettings(_ input: DeleteAccessLogSettingsRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteAccessLogSettings", path: "/v2/apis/{apiId}/stages/{stageName}/accesslogsettings", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes an Api resource.
    @discardableResult public func deleteApi(_ input: DeleteApiRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteApi", path: "/v2/apis/{apiId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes an API mapping.
    @discardableResult public func deleteApiMapping(_ input: DeleteApiMappingRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteApiMapping", path: "/v2/domainnames/{domainName}/apimappings/{apiMappingId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes an Authorizer.
    @discardableResult public func deleteAuthorizer(_ input: DeleteAuthorizerRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteAuthorizer", path: "/v2/apis/{apiId}/authorizers/{authorizerId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes a CORS configuration.
    @discardableResult public func deleteCorsConfiguration(_ input: DeleteCorsConfigurationRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteCorsConfiguration", path: "/v2/apis/{apiId}/cors", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes a Deployment.
    @discardableResult public func deleteDeployment(_ input: DeleteDeploymentRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteDeployment", path: "/v2/apis/{apiId}/deployments/{deploymentId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes a domain name.
    @discardableResult public func deleteDomainName(_ input: DeleteDomainNameRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteDomainName", path: "/v2/domainnames/{domainName}", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes an Integration.
    @discardableResult public func deleteIntegration(_ input: DeleteIntegrationRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteIntegration", path: "/v2/apis/{apiId}/integrations/{integrationId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes an IntegrationResponses.
    @discardableResult public func deleteIntegrationResponse(_ input: DeleteIntegrationResponseRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteIntegrationResponse", path: "/v2/apis/{apiId}/integrations/{integrationId}/integrationresponses/{integrationResponseId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes a Model.
    @discardableResult public func deleteModel(_ input: DeleteModelRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteModel", path: "/v2/apis/{apiId}/models/{modelId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes a Route.
    @discardableResult public func deleteRoute(_ input: DeleteRouteRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteRoute", path: "/v2/apis/{apiId}/routes/{routeId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes a route request parameter.
    @discardableResult public func deleteRouteRequestParameter(_ input: DeleteRouteRequestParameterRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteRouteRequestParameter", path: "/v2/apis/{apiId}/routes/{routeId}/requestparameters/{requestParameterKey}", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes a RouteResponse.
    @discardableResult public func deleteRouteResponse(_ input: DeleteRouteResponseRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteRouteResponse", path: "/v2/apis/{apiId}/routes/{routeId}/routeresponses/{routeResponseId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes the RouteSettings for a stage.
    @discardableResult public func deleteRouteSettings(_ input: DeleteRouteSettingsRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteRouteSettings", path: "/v2/apis/{apiId}/stages/{stageName}/routesettings/{routeKey}", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes a Stage.
    @discardableResult public func deleteStage(_ input: DeleteStageRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "DeleteStage", path: "/v2/apis/{apiId}/stages/{stageName}", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes a VPC link.
    public func deleteVpcLink(_ input: DeleteVpcLinkRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteVpcLinkResponse> {
        return self.client.execute(operation: "DeleteVpcLink", path: "/v2/vpclinks/{vpcLinkId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Exports a definition of an API in a particular output format and specification.
    public func exportApi(_ input: ExportApiRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ExportApiResponse> {
        return self.client.execute(operation: "ExportApi", path: "/v2/apis/{apiId}/exports/{specification}", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets an Api resource.
    public func getApi(_ input: GetApiRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetApiResponse> {
        return self.client.execute(operation: "GetApi", path: "/v2/apis/{apiId}", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets an API mapping.
    public func getApiMapping(_ input: GetApiMappingRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetApiMappingResponse> {
        return self.client.execute(operation: "GetApiMapping", path: "/v2/domainnames/{domainName}/apimappings/{apiMappingId}", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets API mappings.
    public func getApiMappings(_ input: GetApiMappingsRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetApiMappingsResponse> {
        return self.client.execute(operation: "GetApiMappings", path: "/v2/domainnames/{domainName}/apimappings", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets a collection of Api resources.
    public func getApis(_ input: GetApisRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetApisResponse> {
        return self.client.execute(operation: "GetApis", path: "/v2/apis", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets an Authorizer.
    public func getAuthorizer(_ input: GetAuthorizerRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetAuthorizerResponse> {
        return self.client.execute(operation: "GetAuthorizer", path: "/v2/apis/{apiId}/authorizers/{authorizerId}", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets the Authorizers for an API.
    public func getAuthorizers(_ input: GetAuthorizersRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetAuthorizersResponse> {
        return self.client.execute(operation: "GetAuthorizers", path: "/v2/apis/{apiId}/authorizers", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets a Deployment.
    public func getDeployment(_ input: GetDeploymentRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetDeploymentResponse> {
        return self.client.execute(operation: "GetDeployment", path: "/v2/apis/{apiId}/deployments/{deploymentId}", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets the Deployments for an API.
    public func getDeployments(_ input: GetDeploymentsRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetDeploymentsResponse> {
        return self.client.execute(operation: "GetDeployments", path: "/v2/apis/{apiId}/deployments", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets a domain name.
    public func getDomainName(_ input: GetDomainNameRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetDomainNameResponse> {
        return self.client.execute(operation: "GetDomainName", path: "/v2/domainnames/{domainName}", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets the domain names for an AWS account.
    public func getDomainNames(_ input: GetDomainNamesRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetDomainNamesResponse> {
        return self.client.execute(operation: "GetDomainNames", path: "/v2/domainnames", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets an Integration.
    public func getIntegration(_ input: GetIntegrationRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetIntegrationResult> {
        return self.client.execute(operation: "GetIntegration", path: "/v2/apis/{apiId}/integrations/{integrationId}", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets an IntegrationResponses.
    public func getIntegrationResponse(_ input: GetIntegrationResponseRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetIntegrationResponseResponse> {
        return self.client.execute(operation: "GetIntegrationResponse", path: "/v2/apis/{apiId}/integrations/{integrationId}/integrationresponses/{integrationResponseId}", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets the IntegrationResponses for an Integration.
    public func getIntegrationResponses(_ input: GetIntegrationResponsesRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetIntegrationResponsesResponse> {
        return self.client.execute(operation: "GetIntegrationResponses", path: "/v2/apis/{apiId}/integrations/{integrationId}/integrationresponses", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets the Integrations for an API.
    public func getIntegrations(_ input: GetIntegrationsRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetIntegrationsResponse> {
        return self.client.execute(operation: "GetIntegrations", path: "/v2/apis/{apiId}/integrations", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets a Model.
    public func getModel(_ input: GetModelRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetModelResponse> {
        return self.client.execute(operation: "GetModel", path: "/v2/apis/{apiId}/models/{modelId}", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets a model template.
    public func getModelTemplate(_ input: GetModelTemplateRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetModelTemplateResponse> {
        return self.client.execute(operation: "GetModelTemplate", path: "/v2/apis/{apiId}/models/{modelId}/template", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets the Models for an API.
    public func getModels(_ input: GetModelsRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetModelsResponse> {
        return self.client.execute(operation: "GetModels", path: "/v2/apis/{apiId}/models", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets a Route.
    public func getRoute(_ input: GetRouteRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetRouteResult> {
        return self.client.execute(operation: "GetRoute", path: "/v2/apis/{apiId}/routes/{routeId}", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets a RouteResponse.
    public func getRouteResponse(_ input: GetRouteResponseRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetRouteResponseResponse> {
        return self.client.execute(operation: "GetRouteResponse", path: "/v2/apis/{apiId}/routes/{routeId}/routeresponses/{routeResponseId}", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets the RouteResponses for a Route.
    public func getRouteResponses(_ input: GetRouteResponsesRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetRouteResponsesResponse> {
        return self.client.execute(operation: "GetRouteResponses", path: "/v2/apis/{apiId}/routes/{routeId}/routeresponses", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets the Routes for an API.
    public func getRoutes(_ input: GetRoutesRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetRoutesResponse> {
        return self.client.execute(operation: "GetRoutes", path: "/v2/apis/{apiId}/routes", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets a Stage.
    public func getStage(_ input: GetStageRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetStageResponse> {
        return self.client.execute(operation: "GetStage", path: "/v2/apis/{apiId}/stages/{stageName}", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets the Stages for an API.
    public func getStages(_ input: GetStagesRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetStagesResponse> {
        return self.client.execute(operation: "GetStages", path: "/v2/apis/{apiId}/stages", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets a collection of Tag resources.
    public func getTags(_ input: GetTagsRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetTagsResponse> {
        return self.client.execute(operation: "GetTags", path: "/v2/tags/{resource-arn}", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets a VPC link.
    public func getVpcLink(_ input: GetVpcLinkRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetVpcLinkResponse> {
        return self.client.execute(operation: "GetVpcLink", path: "/v2/vpclinks/{vpcLinkId}", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Gets a collection of VPC links.
    public func getVpcLinks(_ input: GetVpcLinksRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetVpcLinksResponse> {
        return self.client.execute(operation: "GetVpcLinks", path: "/v2/vpclinks", httpMethod: .GET, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Imports an API.
    public func importApi(_ input: ImportApiRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ImportApiResponse> {
        return self.client.execute(operation: "ImportApi", path: "/v2/apis", httpMethod: .PUT, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Puts an Api resource.
    public func reimportApi(_ input: ReimportApiRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ReimportApiResponse> {
        return self.client.execute(operation: "ReimportApi", path: "/v2/apis/{apiId}", httpMethod: .PUT, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Resets all authorizer cache entries for the specified stage. Supported only for HTTP API Lambda authorizers.
    @discardableResult public func resetAuthorizersCache(_ input: ResetAuthorizersCacheRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "ResetAuthorizersCache", path: "/v2/apis/{apiId}/stages/{stageName}/cache/authorizers", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Creates a new Tag resource to represent a tag.
    public func tagResource(_ input: TagResourceRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<TagResourceResponse> {
        return self.client.execute(operation: "TagResource", path: "/v2/tags/{resource-arn}", httpMethod: .POST, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Deletes a Tag.
    @discardableResult public func untagResource(_ input: UntagResourceRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<Void> {
        return self.client.execute(operation: "UntagResource", path: "/v2/tags/{resource-arn}", httpMethod: .DELETE, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Updates an Api resource.
    public func updateApi(_ input: UpdateApiRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateApiResponse> {
        return self.client.execute(operation: "UpdateApi", path: "/v2/apis/{apiId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// The API mapping.
    public func updateApiMapping(_ input: UpdateApiMappingRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateApiMappingResponse> {
        return self.client.execute(operation: "UpdateApiMapping", path: "/v2/domainnames/{domainName}/apimappings/{apiMappingId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Updates an Authorizer.
    public func updateAuthorizer(_ input: UpdateAuthorizerRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateAuthorizerResponse> {
        return self.client.execute(operation: "UpdateAuthorizer", path: "/v2/apis/{apiId}/authorizers/{authorizerId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Updates a Deployment.
    public func updateDeployment(_ input: UpdateDeploymentRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateDeploymentResponse> {
        return self.client.execute(operation: "UpdateDeployment", path: "/v2/apis/{apiId}/deployments/{deploymentId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Updates a domain name.
    public func updateDomainName(_ input: UpdateDomainNameRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateDomainNameResponse> {
        return self.client.execute(operation: "UpdateDomainName", path: "/v2/domainnames/{domainName}", httpMethod: .PATCH, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Updates an Integration.
    public func updateIntegration(_ input: UpdateIntegrationRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateIntegrationResult> {
        return self.client.execute(operation: "UpdateIntegration", path: "/v2/apis/{apiId}/integrations/{integrationId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Updates an IntegrationResponses.
    public func updateIntegrationResponse(_ input: UpdateIntegrationResponseRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateIntegrationResponseResponse> {
        return self.client.execute(operation: "UpdateIntegrationResponse", path: "/v2/apis/{apiId}/integrations/{integrationId}/integrationresponses/{integrationResponseId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Updates a Model.
    public func updateModel(_ input: UpdateModelRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateModelResponse> {
        return self.client.execute(operation: "UpdateModel", path: "/v2/apis/{apiId}/models/{modelId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Updates a Route.
    public func updateRoute(_ input: UpdateRouteRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateRouteResult> {
        return self.client.execute(operation: "UpdateRoute", path: "/v2/apis/{apiId}/routes/{routeId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Updates a RouteResponse.
    public func updateRouteResponse(_ input: UpdateRouteResponseRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateRouteResponseResponse> {
        return self.client.execute(operation: "UpdateRouteResponse", path: "/v2/apis/{apiId}/routes/{routeId}/routeresponses/{routeResponseId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Updates a Stage.
    public func updateStage(_ input: UpdateStageRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateStageResponse> {
        return self.client.execute(operation: "UpdateStage", path: "/v2/apis/{apiId}/stages/{stageName}", httpMethod: .PATCH, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }

    /// Updates a VPC link.
    public func updateVpcLink(_ input: UpdateVpcLinkRequest, context: LoggingContext, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateVpcLinkResponse> {
        return self.client.execute(operation: "UpdateVpcLink", path: "/v2/vpclinks/{vpcLinkId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, context: context, on: eventLoop)
    }
}

extension ApiGatewayV2 {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are no public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: ApiGatewayV2, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}
